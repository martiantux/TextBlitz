import{C as M,a as m}from"./case-transform.js";import{l as p}from"./logger.js";class C{constructor(){this.debugMode=!1}setDebugMode(t){this.debugMode=t}log(...t){this.debugMode&&console.log(`[${this.name}]`,...t)}async delay(t){return new Promise(e=>setTimeout(e,t))}getElementText(t){return t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement?t.value:t.textContent||""}findTrigger(t,e){if(t.endsWith(e))return{start:t.length-e.length,end:t.length};const n=t.lastIndexOf(e);return n!==-1?{start:n,end:n+e.length}:null}verify(t,e,n){const s=this.getElementText(t),i=e.substring(0,Math.min(10,e.length));return s.includes(i)?s.endsWith(n)?(this.log("Verification failed: trigger still present"),!1):!0:(this.log("Verification failed: expansion not found"),!1)}async executeKeyboardAction(t,e){switch(e.type){case"enter":await this.executeEnter(t);break;case"tab":await this.executeTab(t);break;case"delay":await this.executeDelay(e.options);break}}async executeEnter(t){if(this.log("Executing {enter}"),t instanceof HTMLTextAreaElement||t.isContentEditable){const e=new KeyboardEvent("keydown",{key:"Enter",code:"Enter",keyCode:13,bubbles:!0,cancelable:!0});t.dispatchEvent(e)}else if(t instanceof HTMLInputElement){const e=t.form;e?e.dispatchEvent(new Event("submit",{bubbles:!0,cancelable:!0})):t.blur()}}async executeTab(t){this.log("Executing {tab}");const e=Array.from(document.querySelectorAll('input:not([disabled]):not([type="hidden"]), textarea:not([disabled]), select:not([disabled]), button:not([disabled]), [contenteditable="true"], [tabindex]:not([tabindex="-1"])')),n=e.indexOf(t);n!==-1&&n<e.length-1&&e[n+1].focus()}async executeDelay(t){let n=1e3;if(t){const s=t.match(/\+?(\d+(?:\.\d+)?)(s|ms)?/);if(s){const i=parseFloat(s[1]);n=(s[2]||"s")==="ms"?i:i*1e3}}this.log(`Executing {delay} for ${n}ms`),await this.delay(n)}}class S{static isGoogleDocs(t){return!!(window.location.hostname.includes("docs.google.com")||t&&(t.classList.contains("kix-cursor")||t.closest(".kix-appview-editor")||document.querySelector(".kix-appview-editor")))}static isReact(t){return Object.keys(t).some(n=>n.startsWith("__react")||n.startsWith("_react")||n.startsWith("__REACT"))}static isVue(t){return"__vue__"in t||"__vueParentComponent"in t||"__v_skip"in t}static isShadowDOM(t){return!!t.shadowRoot||!!t.closest("[shadowroot]")}static isCustomEditor(t){return t.classList.contains("CodeMirror")||t.classList.contains("monaco-editor")||t.getAttribute("data-lexical-editor")!==null||t.classList.contains("ProseMirror")}static getSiteType(t){return this.isGoogleDocs(t)?"google-docs":this.isCustomEditor(t)?"custom-editor":this.isReact(t)?"react":this.isVue(t)?"vue":this.isShadowDOM(t)?"shadow-dom":"standard"}}class A extends C{constructor(){super(...arguments),this.name="GoogleDocs",this.priority=10}canHandle(t){return S.isGoogleDocs(t)}async replace(t,e,n,s,i,l){if(this.log("Starting Google Docs replacement"),t.focus(),await this.delay(50),!this.getElementText(t).endsWith(e))return this.log("Trigger not found at end of text"),!1;for(let u=0;u<e.length;u++)document.execCommand("delete",!1);await this.delay(100);let r=0,a=this.getElementText(t);for(;a.endsWith(e)&&r<3;){this.log(`Deletion retry ${r+1}/3`);const u=window.getSelection();if(u&&u.rangeCount>0){const d=u.getRangeAt(0);let{startContainer:h,startOffset:g}=d;if(h.nodeType!==Node.TEXT_NODE&&h.childNodes.length>0){const f=Math.min(g,h.childNodes.length-1),b=h.childNodes[f];b&&b.nodeType===Node.TEXT_NODE&&(h=b,g=b.textContent?.length||0)}if(h.nodeType===Node.TEXT_NODE){const f=h;if((f.textContent||"").substring(0,g).endsWith(e)){const E=document.createRange();E.setStart(f,g-e.length),E.setEnd(f,g),u.removeAllRanges(),u.addRange(E),document.execCommand("delete",!1),await this.delay(100)}}}r++,a=this.getElementText(t)}return a.endsWith(e)?(this.log("Deletion failed after retries"),!1):(await this.delay(50),i&&i.length>0&&l&&l.length>0?await this.replaceWithChunks(t,i,l,e,n):document.execCommand("insertText",!1,n)?(s!==void 0&&s<n.length&&await this.setCursorPosition(t,s,n),await this.delay(200),this.verify(t,n,e)):(this.log("insertText failed"),!1))}async replaceWithChunks(t,e,n,s,i){this.log(`Replacing with ${e.length} chunks and ${n.length} actions`);for(let l=0;l<e.length;l++){if(!document.execCommand("insertText",!1,e[l]))return this.log(`Failed to insert chunk ${l}`),!1;await this.delay(100),l<n.length&&(await this.executeKeyboardAction(t,n[l]),await this.delay(100))}return await this.delay(200),this.verify(t,i,s)}async setCursorPosition(t,e,n){this.log(`Setting cursor position to offset ${e}`);const s=window.getSelection();if(!(!s||s.rangeCount===0))try{const i=s.getRangeAt(0),{startContainer:l}=i;if(l.nodeType===Node.TEXT_NODE){const o=l,r=o.textContent||"",a=r.length-(n.length-e);a>=0&&a<=r.length&&(i.setStart(o,a),i.setEnd(o,a),s.removeAllRanges(),s.addRange(i))}}catch(i){this.log("Failed to set cursor position:",i)}}}class R extends C{constructor(){super(...arguments),this.name="React",this.priority=5}canHandle(t){return S.isReact(t)&&(t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement)}async replace(t,e,n,s,i,l){if(!(t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement))return!1;this.log("Starting React-specific replacement");const o=t.value,r=t.selectionStart??o.length;let a=-1,c=-1;if(o.substring(0,r).endsWith(e)?(a=r-e.length,c=r):o.endsWith(e)?(a=o.length-e.length,c=o.length):(a=o.lastIndexOf(e),a!==-1&&(c=a+e.length)),a===-1)return this.log("Trigger not found"),!1;const d=o.substring(0,a),h=o.substring(c);if(i&&i.length>0&&l&&l.length>0)return await this.replaceWithChunks(t,d,h,i,l,e,n,s);const g=d+n+h,f=Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype,"value")?.set,b=Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype,"value")?.set;t instanceof HTMLInputElement&&f?f.call(t,g):t instanceof HTMLTextAreaElement&&b?b.call(t,g):t.value=g;const y=t._valueTracker;y&&y.setValue(""),t.dispatchEvent(new Event("input",{bubbles:!0})),t.dispatchEvent(new Event("change",{bubbles:!0}));const E=d.length+(s??n.length);try{t.setSelectionRange(E,E)}catch{}return await this.delay(10),this.verify(t,n,e)}async replaceWithChunks(t,e,n,s,i,l,o,r){this.log(`Replacing with ${s.length} chunks and ${i.length} actions`);const a=Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype,"value")?.set,c=Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype,"value")?.set;let u=e;for(let d=0;d<s.length;d++){if(s[d].length===0&&d<s.length-1){d<i.length&&await this.executeKeyboardAction(t,i[d]);continue}u+=s[d];const h=u+n;t instanceof HTMLInputElement&&a?a.call(t,h):t instanceof HTMLTextAreaElement&&c?c.call(t,h):t.value=h;const g=t._valueTracker;g&&g.setValue(""),t.dispatchEvent(new Event("input",{bubbles:!0}));const f=u.length;try{t.setSelectionRange(f,f)}catch{}d<i.length&&await this.executeKeyboardAction(t,i[d])}if(r!==void 0){const d=e.length+r;try{t.setSelectionRange(d,d),this.log(`Set cursor to offset ${r} (absolute pos ${d})`)}catch(h){this.log("Failed to set cursor position:",h)}}return t.dispatchEvent(new Event("change",{bubbles:!0})),await this.delay(10),this.verify(t,o,l)}}class D extends C{constructor(){super(...arguments),this.name="ContentEditable",this.priority=3}canHandle(t){return t.isContentEditable}async replace(t,e,n,s,i,l){this.log("Starting contenteditable replacement");const o=window.getSelection();if(!o||o.rangeCount===0)return this.log("No selection available"),!1;const r=o.getRangeAt(0);let{startContainer:a,startOffset:c}=r;if(a.nodeType!==Node.TEXT_NODE)if(a.childNodes.length>0){const E=Math.min(c,a.childNodes.length-1),w=a.childNodes[E];if(w&&w.nodeType===Node.TEXT_NODE)a=w,c=w.textContent?.length||0;else return this.log("Could not find text node"),!1}else return this.log("No child nodes"),!1;const u=a;if(!(u.textContent||"").substring(0,c).endsWith(e))return this.log("Trigger not found before cursor"),!1;const g=document.createRange(),f=c-e.length;return g.setStart(u,f),g.setEnd(u,c),o.removeAllRanges(),o.addRange(g),document.execCommand("delete",!1)?i&&i.length>0&&l&&l.length>0?await this.replaceWithChunks(t,i,l,e,n,s):document.execCommand("insertText",!1,n)?(s!==void 0&&s<n.length&&await this.setCursorPosition(t,s,n),t.dispatchEvent(new Event("input",{bubbles:!0})),await this.delay(10),this.verify(t,n,e)):(this.log("InsertText command failed"),!1):(this.log("Delete command failed"),!1)}async replaceWithChunks(t,e,n,s,i,l){this.log(`Replacing with ${e.length} chunks and ${n.length} actions`);let o=0;for(let r=0;r<e.length;r++){if(e[r].length===0&&r<e.length-1){r<n.length&&await this.executeKeyboardAction(t,n[r]);continue}if(!document.execCommand("insertText",!1,e[r]))return this.log(`Failed to insert chunk ${r}`),!1;o+=e[r].length,t.dispatchEvent(new Event("input",{bubbles:!0})),r<n.length&&await this.executeKeyboardAction(t,n[r])}return l!==void 0&&l<o&&await this.setCursorFromEnd(t,o-l),await this.delay(10),this.verify(t,i,s)}async setCursorFromEnd(t,e){const n=window.getSelection();if(!(!n||n.rangeCount===0))try{const s=n.getRangeAt(0),{startContainer:i,startOffset:l}=s;if(i.nodeType===Node.TEXT_NODE){const o=i,r=Math.max(0,l-e);s.setStart(o,r),s.setEnd(o,r),n.removeAllRanges(),n.addRange(s),this.log(`Moved cursor back ${e} chars to position ${r}`)}}catch(s){this.log("Failed to move cursor:",s)}}async setCursorPosition(t,e,n){this.log(`Setting cursor position to offset ${e}`);const s=window.getSelection();if(!(!s||s.rangeCount===0))try{const i=s.getRangeAt(0),{startContainer:l}=i;if(l.nodeType===Node.TEXT_NODE){const o=l,r=o.textContent||"",a=r.length-(n.length-e);a>=0&&a<=r.length&&(i.setStart(o,a),i.setEnd(o,a),s.removeAllRanges(),s.addRange(i))}}catch(i){this.log("Failed to set cursor position:",i)}}}class L extends C{constructor(){super(...arguments),this.name="Standard",this.priority=1}canHandle(t){return t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement}async replace(t,e,n,s,i,l){if(!(t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement))return!1;this.log("Starting standard replacement");const o=t.value,r=t.selectionStart??o.length,a=this.findTrigger(o.substring(0,r),e);if(!a)return this.log("Trigger not found"),!1;const c=o.substring(0,a.start),u=o.substring(r);if(i&&i.length>0&&l&&l.length>0)return await this.replaceWithChunks(t,c,u,i,l,e,n,s);const d=c+n+u;t.value=d;const h=c.length+(s??n.length);try{t.setSelectionRange(h,h)}catch{}return t.dispatchEvent(new Event("input",{bubbles:!0})),t.dispatchEvent(new Event("change",{bubbles:!0})),await this.delay(10),this.verify(t,n,e)}async replaceWithChunks(t,e,n,s,i,l,o,r){this.log(`Replacing with ${s.length} chunks and ${i.length} actions`);let a=e;for(let c=0;c<s.length;c++){if(s[c].length===0&&c<s.length-1){c<i.length&&await this.executeKeyboardAction(t,i[c]);continue}a+=s[c],t.value=a+n,t.dispatchEvent(new Event("input",{bubbles:!0}));const u=a.length;try{t.setSelectionRange(u,u)}catch{}c<i.length&&await this.executeKeyboardAction(t,i[c])}if(r!==void 0){const c=e.length+r;try{t.setSelectionRange(c,c),this.log(`Set cursor to offset ${r} (absolute pos ${c})`)}catch(u){this.log("Failed to set cursor position:",u)}}return t.dispatchEvent(new Event("change",{bubbles:!0})),await this.delay(10),this.verify(t,o,l)}}class ${constructor(){this.handlers=[],this.debugMode=!1,this.register(new A),this.register(new R),this.register(new D),this.register(new L),this.handlers.sort((t,e)=>e.priority-t.priority)}register(t){this.handlers.push(t)}setDebugMode(t){this.debugMode=t,this.handlers.forEach(e=>{"setDebugMode"in e&&e.setDebugMode(t)})}getHandler(t){for(const e of this.handlers)if(e.canHandle(t))return this.debugMode&&console.log(`TextBlitz: Selected handler: ${e.name}`),e;return null}getHandlerChain(t){return this.handlers.filter(e=>e.canHandle(t))}listHandlers(){return this.handlers.map(t=>`${t.name} (priority: ${t.priority})`)}}const v=class v{static setDebugMode(t){this.debugMode=t,this.registry.setDebugMode(t),p.setDebugMode(t)}static log(...t){this.debugMode&&console.log("TextBlitz [Replacer]:",...t)}static async replace(t,e,n,s,i){const l=i||e,o={element:p.getElementContext(t),site:p.getSiteContext(),snippet:{trigger:e}};try{if(p.info("expansion","Starting replacement",o),!document.contains(t))return p.warn("expansion","Element not in document",o),!1;let r=await M.processCommands(n);s&&s!=="none"&&(r=m.transform(r,s,e));const a="{cursor}";let c;const u=r.lastIndexOf(a);if(u!==-1){const T=(r.match(/\{cursor\}/g)||[]).length;r=r.replace(/\{cursor\}/g,""),c=u-a.length*(T-1),this.log(`Cursor position: ${c} (removed ${T} markers)`)}const{chunks:d,actions:h}=M.splitTextByKeyboardActions(r),g=d.join("");this.log("Final expansion:",g),d.length>1&&this.log(`Split into ${d.length} chunks with ${h.length} actions`);const f=this.registry.getHandler(t);if(!f)return p.error("expansion","No handler available for element",o),!1;p.info("handler",`Using ${f.name} handler`,o);const b=this.getElementText(t),y=d.length>1&&h.length>0;if(await f.replace(t,l,g,c,y?d:void 0,y?h:void 0))return p.info("success",`${f.name} handler succeeded`,o),!0;p.warn("handler",`${f.name} handler failed, trying fallback chain`,o);const w=this.registry.getHandlerChain(t);for(const T of w){if(T===f)continue;if(p.info("fallback",`Trying fallback: ${T.name}`,o),await T.replace(t,l,g,c,y?d:void 0,y?h:void 0))return p.info("success",`Fallback ${T.name} succeeded`,o),!0}return p.error("fail","All handlers failed, rolling back",o),this.rollback(t,b),!1}catch(r){const a={...o,error:r instanceof Error?r.message:String(r)};return p.error("fail","Fatal error in replace",a),console.error("TextBlitz: Fatal error:",r),!1}}static getElementText(t){return t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement?t.value:t.textContent||""}static rollback(t,e){try{t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement?(t.value=e,t.dispatchEvent(new Event("input",{bubbles:!0}))):t.isContentEditable&&(t.textContent=e,t.dispatchEvent(new Event("input",{bubbles:!0}))),this.log("Rolled back to previous content")}catch(n){console.error("TextBlitz: Rollback failed:",n)}}static isValidInputElement(t){return t instanceof HTMLInputElement&&t.type==="password"||t instanceof HTMLInputElement&&t.type==="hidden"||t instanceof HTMLInputElement&&["number","date","time","color","range","file","datetime-local","month","week"].includes(t.type)?!1:t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement||t.isContentEditable}static listHandlers(){return this.registry.listHandlers()}};v.debugMode=!1,v.registry=new $;let H=v;export{H as TextReplacer};
