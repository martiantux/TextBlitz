import{C as m,a as S}from"./case-transform.js";import{l as p}from"./logger.js";import{_ as A}from"../ui/options/options.js";import"./storage.js";class M{constructor(){this.debugMode=!1}setDebugMode(t){this.debugMode=t}log(...t){this.debugMode&&console.log(`[${this.name}]`,...t)}async delay(t){return new Promise(e=>setTimeout(e,t))}getElementText(t){return t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement?t.value:t.textContent||""}findTrigger(t,e){if(t.endsWith(e))return{start:t.length-e.length,end:t.length};const n=t.lastIndexOf(e);return n!==-1?{start:n,end:n+e.length}:null}verify(t,e,n){const s=this.getElementText(t),i=e.substring(0,Math.min(10,e.length));return s.includes(i)?s.endsWith(n)?(this.log("Verification failed: trigger still present"),!1):!0:(this.log("Verification failed: expansion not found"),!1)}async executeKeyboardAction(t,e){switch(e.type){case"enter":await this.executeEnter(t);break;case"tab":await this.executeTab(t);break;case"delay":await this.executeDelay(e.options);break;case"key":await this.executeKey(t,e.options);break}}async executeEnter(t){if(this.log("Executing {enter}"),t instanceof HTMLTextAreaElement||t.isContentEditable){const e=new KeyboardEvent("keydown",{key:"Enter",code:"Enter",keyCode:13,bubbles:!0,cancelable:!0});t.dispatchEvent(e)}else if(t instanceof HTMLInputElement){const e=t.form;e?e.dispatchEvent(new Event("submit",{bubbles:!0,cancelable:!0})):t.blur()}}async executeTab(t){this.log("Executing {tab}");const e=Array.from(document.querySelectorAll('input:not([disabled]):not([type="hidden"]), textarea:not([disabled]), select:not([disabled]), button:not([disabled]), [contenteditable="true"], [tabindex]:not([tabindex="-1"])')),n=e.indexOf(t);n!==-1&&n<e.length-1&&e[n+1].focus()}async executeDelay(t){let n=1e3;if(t){const s=t.match(/\+?(\d+(?:\.\d+)?)(s|ms)?/);if(s){const i=parseFloat(s[1]);n=(s[2]||"s")==="ms"?i:i*1e3}}this.log(`Executing {delay} for ${n}ms`),await this.delay(n)}async executeKey(t,e){if(!e){console.warn("TextBlitz: {key} command requires a key name");return}const{CommandParser:n}=await A(async()=>{const{CommandParser:a}=await import("./case-transform.js").then(r=>r.c);return{CommandParser:a}},[]),s=n.normalizeKeyName(e);if(!s){console.warn(`TextBlitz: Unknown key name: ${e}`);return}this.log(`Executing {key: ${e}} â†’ ${s.code}`);const i=new KeyboardEvent("keydown",{key:s.key,code:s.code,keyCode:s.keyCode,bubbles:!0,cancelable:!0});t.dispatchEvent(i)}}class H{static isGoogleDocs(t){return!!(window.location.hostname.includes("docs.google.com")||t&&(t.classList.contains("kix-cursor")||t.closest(".kix-appview-editor")||document.querySelector(".kix-appview-editor")))}static isReact(t){return Object.keys(t).some(n=>n.startsWith("__react")||n.startsWith("_react")||n.startsWith("__REACT"))}static isVue(t){return"__vue__"in t||"__vueParentComponent"in t||"__v_skip"in t}static isShadowDOM(t){return!!t.shadowRoot||!!t.closest("[shadowroot]")}static isCustomEditor(t){return t.classList.contains("CodeMirror")||t.classList.contains("monaco-editor")||t.getAttribute("data-lexical-editor")!==null||t.classList.contains("ProseMirror")}static getSiteType(t){return this.isGoogleDocs(t)?"google-docs":this.isCustomEditor(t)?"custom-editor":this.isReact(t)?"react":this.isVue(t)?"vue":this.isShadowDOM(t)?"shadow-dom":"standard"}}class D extends M{constructor(){super(...arguments),this.name="GoogleDocs",this.priority=10}canHandle(t){return H.isGoogleDocs(t)}async replace(t,e,n,s,i,a){if(this.log("Starting Google Docs replacement"),t.focus(),await this.delay(50),!this.getElementText(t).endsWith(e))return this.log("Trigger not found at end of text"),!1;for(let u=0;u<e.length;u++)document.execCommand("delete",!1);await this.delay(100);let o=0,l=this.getElementText(t);for(;l.endsWith(e)&&o<3;){this.log(`Deletion retry ${o+1}/3`);const u=window.getSelection();if(u&&u.rangeCount>0){const d=u.getRangeAt(0);let{startContainer:h,startOffset:f}=d;if(h.nodeType!==Node.TEXT_NODE&&h.childNodes.length>0){const g=Math.min(f,h.childNodes.length-1),b=h.childNodes[g];b&&b.nodeType===Node.TEXT_NODE&&(h=b,f=b.textContent?.length||0)}if(h.nodeType===Node.TEXT_NODE){const g=h;if((g.textContent||"").substring(0,f).endsWith(e)){const w=document.createRange();w.setStart(g,f-e.length),w.setEnd(g,f),u.removeAllRanges(),u.addRange(w),document.execCommand("delete",!1),await this.delay(100)}}}o++,l=this.getElementText(t)}return l.endsWith(e)?(this.log("Deletion failed after retries"),!1):(await this.delay(50),i&&i.length>0&&a&&a.length>0?await this.replaceWithChunks(t,i,a,e,n):document.execCommand("insertText",!1,n)?(s!==void 0&&s<n.length&&await this.setCursorPosition(t,s,n),await this.delay(200),this.verify(t,n,e)):(this.log("insertText failed"),!1))}async replaceWithChunks(t,e,n,s,i){this.log(`Replacing with ${e.length} chunks and ${n.length} actions`);for(let a=0;a<e.length;a++){if(!document.execCommand("insertText",!1,e[a]))return this.log(`Failed to insert chunk ${a}`),!1;await this.delay(100),a<n.length&&(await this.executeKeyboardAction(t,n[a]),await this.delay(100))}return await this.delay(200),this.verify(t,i,s)}async setCursorPosition(t,e,n){this.log(`Setting cursor position to offset ${e}`);const s=window.getSelection();if(!(!s||s.rangeCount===0))try{const i=s.getRangeAt(0),{startContainer:a}=i;if(a.nodeType===Node.TEXT_NODE){const r=a,o=r.textContent||"",l=o.length-(n.length-e);l>=0&&l<=o.length&&(i.setStart(r,l),i.setEnd(r,l),s.removeAllRanges(),s.addRange(i))}}catch(i){this.log("Failed to set cursor position:",i)}}}class R extends M{constructor(){super(...arguments),this.name="React",this.priority=5}canHandle(t){return H.isReact(t)&&(t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement)}async replace(t,e,n,s,i,a){if(!(t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement))return!1;this.log("Starting React-specific replacement");const r=t.value,o=t.selectionStart??r.length;let l=-1,c=-1;if(r.substring(0,o).endsWith(e)?(l=o-e.length,c=o):r.endsWith(e)?(l=r.length-e.length,c=r.length):(l=r.lastIndexOf(e),l!==-1&&(c=l+e.length)),l===-1)return this.log("Trigger not found"),!1;const d=r.substring(0,l),h=r.substring(c);if(i&&i.length>0&&a&&a.length>0)return await this.replaceWithChunks(t,d,h,i,a,e,n,s);const f=d+n+h,g=Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype,"value")?.set,b=Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype,"value")?.set;t instanceof HTMLInputElement&&g?g.call(t,f):t instanceof HTMLTextAreaElement&&b?b.call(t,f):t.value=f;const y=t._valueTracker;y&&y.setValue(""),t.dispatchEvent(new Event("input",{bubbles:!0})),t.dispatchEvent(new Event("change",{bubbles:!0}));const w=d.length+(s??n.length);try{t.setSelectionRange(w,w)}catch{}return await this.delay(10),this.verify(t,n,e)}async replaceWithChunks(t,e,n,s,i,a,r,o){this.log(`Replacing with ${s.length} chunks and ${i.length} actions`);const l=Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype,"value")?.set,c=Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype,"value")?.set;let u=e;for(let d=0;d<s.length;d++){if(s[d].length===0&&d<s.length-1){d<i.length&&await this.executeKeyboardAction(t,i[d]);continue}u+=s[d];const h=u+n;t instanceof HTMLInputElement&&l?l.call(t,h):t instanceof HTMLTextAreaElement&&c?c.call(t,h):t.value=h;const f=t._valueTracker;f&&f.setValue(""),t.dispatchEvent(new Event("input",{bubbles:!0}));const g=u.length;try{t.setSelectionRange(g,g)}catch{}d<i.length&&await this.executeKeyboardAction(t,i[d])}if(o!==void 0){const d=e.length+o;try{t.setSelectionRange(d,d),this.log(`Set cursor to offset ${o} (absolute pos ${d})`)}catch(h){this.log("Failed to set cursor position:",h)}}return t.dispatchEvent(new Event("change",{bubbles:!0})),await this.delay(10),this.verify(t,r,a)}}class $ extends M{constructor(){super(...arguments),this.name="ContentEditable",this.priority=3}canHandle(t){return t.isContentEditable}async replace(t,e,n,s,i,a){this.log("Starting contenteditable replacement");const r=window.getSelection();if(!r||r.rangeCount===0)return this.log("No selection available"),!1;const o=r.getRangeAt(0);let{startContainer:l,startOffset:c}=o;if(l.nodeType!==Node.TEXT_NODE)if(l.childNodes.length>0){const w=Math.min(c,l.childNodes.length-1),E=l.childNodes[w];if(E&&E.nodeType===Node.TEXT_NODE)l=E,c=E.textContent?.length||0;else return this.log("Could not find text node"),!1}else return this.log("No child nodes"),!1;const u=l;if(!(u.textContent||"").substring(0,c).endsWith(e))return this.log("Trigger not found before cursor"),!1;const f=document.createRange(),g=c-e.length;return f.setStart(u,g),f.setEnd(u,c),r.removeAllRanges(),r.addRange(f),document.execCommand("delete",!1)?i&&i.length>0&&a&&a.length>0?await this.replaceWithChunks(t,i,a,e,n,s):document.execCommand("insertText",!1,n)?(s!==void 0&&s<n.length&&await this.setCursorPosition(t,s,n),t.dispatchEvent(new Event("input",{bubbles:!0})),await this.delay(10),this.verify(t,n,e)):(this.log("InsertText command failed"),!1):(this.log("Delete command failed"),!1)}async replaceWithChunks(t,e,n,s,i,a){this.log(`Replacing with ${e.length} chunks and ${n.length} actions`);let r=0;for(let o=0;o<e.length;o++){if(e[o].length===0&&o<e.length-1){o<n.length&&await this.executeKeyboardAction(t,n[o]);continue}if(!document.execCommand("insertText",!1,e[o]))return this.log(`Failed to insert chunk ${o}`),!1;r+=e[o].length,t.dispatchEvent(new Event("input",{bubbles:!0})),o<n.length&&await this.executeKeyboardAction(t,n[o])}return a!==void 0&&a<r&&await this.setCursorFromEnd(t,r-a),await this.delay(10),this.verify(t,i,s)}async setCursorFromEnd(t,e){const n=window.getSelection();if(!(!n||n.rangeCount===0))try{const s=n.getRangeAt(0),{startContainer:i,startOffset:a}=s;if(i.nodeType===Node.TEXT_NODE){const r=i,o=Math.max(0,a-e);s.setStart(r,o),s.setEnd(r,o),n.removeAllRanges(),n.addRange(s),this.log(`Moved cursor back ${e} chars to position ${o}`)}}catch(s){this.log("Failed to move cursor:",s)}}async setCursorPosition(t,e,n){this.log(`Setting cursor position to offset ${e}`);const s=window.getSelection();if(!(!s||s.rangeCount===0))try{const i=s.getRangeAt(0),{startContainer:a}=i;if(a.nodeType===Node.TEXT_NODE){const r=a,o=r.textContent||"",l=o.length-(n.length-e);l>=0&&l<=o.length&&(i.setStart(r,l),i.setEnd(r,l),s.removeAllRanges(),s.addRange(i))}}catch(i){this.log("Failed to set cursor position:",i)}}}class I extends M{constructor(){super(...arguments),this.name="Standard",this.priority=1}canHandle(t){return t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement}async replace(t,e,n,s,i,a){if(!(t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement))return!1;this.log("Starting standard replacement");const r=t.value,o=t.selectionStart??r.length,l=this.findTrigger(r.substring(0,o),e);if(!l)return this.log("Trigger not found"),!1;const c=r.substring(0,l.start),u=r.substring(o);if(i&&i.length>0&&a&&a.length>0)return await this.replaceWithChunks(t,c,u,i,a,e,n,s);const d=c+n+u;t.value=d;const h=c.length+(s??n.length);try{t.setSelectionRange(h,h)}catch{}return t.dispatchEvent(new Event("input",{bubbles:!0})),t.dispatchEvent(new Event("change",{bubbles:!0})),await this.delay(10),this.verify(t,n,e)}async replaceWithChunks(t,e,n,s,i,a,r,o){this.log(`Replacing with ${s.length} chunks and ${i.length} actions`);let l=e;for(let c=0;c<s.length;c++){if(s[c].length===0&&c<s.length-1){c<i.length&&await this.executeKeyboardAction(t,i[c]);continue}l+=s[c],t.value=l+n,t.dispatchEvent(new Event("input",{bubbles:!0}));const u=l.length;try{t.setSelectionRange(u,u)}catch{}c<i.length&&await this.executeKeyboardAction(t,i[c])}if(o!==void 0){const c=e.length+o;try{t.setSelectionRange(c,c),this.log(`Set cursor to offset ${o} (absolute pos ${c})`)}catch(u){this.log("Failed to set cursor position:",u)}}return t.dispatchEvent(new Event("change",{bubbles:!0})),await this.delay(10),this.verify(t,r,a)}}class L{constructor(){this.handlers=[],this.debugMode=!1,this.register(new D),this.register(new R),this.register(new $),this.register(new I),this.handlers.sort((t,e)=>e.priority-t.priority)}register(t){this.handlers.push(t)}setDebugMode(t){this.debugMode=t,this.handlers.forEach(e=>{"setDebugMode"in e&&e.setDebugMode(t)})}getHandler(t){for(const e of this.handlers)if(e.canHandle(t))return this.debugMode&&console.log(`TextBlitz: Selected handler: ${e.name}`),e;return null}getHandlerChain(t){return this.handlers.filter(e=>e.canHandle(t))}listHandlers(){return this.handlers.map(t=>`${t.name} (priority: ${t.priority})`)}}class T{constructor(){this.locks=new WeakMap}static getInstance(){return T.instance||(T.instance=new T),T.instance}isLocked(t){const e=this.locks.get(t);return e?Date.now()-e.lastExpansion<e.cooldownMs:!1}lock(t,e=500){return this.isLocked(t)?!1:(this.locks.set(t,{locked:!0,lastExpansion:Date.now(),cooldownMs:e}),!0)}unlock(t){const e=this.locks.get(t);e&&(e.locked=!1,e.lastExpansion=Date.now())}markFailed(t){this.locks.set(t,{locked:!0,lastExpansion:Date.now(),cooldownMs:5e3})}}const C=class C{static setDebugMode(t){this.debugMode=t,this.registry.setDebugMode(t),p.setDebugMode(t)}static log(...t){this.debugMode&&console.log("TextBlitz [Replacer]:",...t)}static async replace(t,e,n,s,i){const a=i||e,r={element:p.getElementContext(t),site:p.getSiteContext(),snippet:{trigger:e}};try{if(p.info("expansion","Starting replacement",r),!document.contains(t))return p.warn("expansion","Element not in document",r),!1;let o=m.stripNotes(n);o=await m.processCommands(o),s&&s!=="none"&&(o=S.transform(o,s,e));const l="{cursor}";let c;const u=o.lastIndexOf(l);if(u!==-1){const x=(o.match(/\{cursor\}/g)||[]).length;o=o.replace(/\{cursor\}/g,""),c=u-l.length*(x-1),this.log(`Cursor position: ${c} (removed ${x} markers)`)}const{chunks:d,actions:h}=m.splitTextByKeyboardActions(o),f=d.join("");this.log("Final expansion:",f),d.length>1&&this.log(`Split into ${d.length} chunks with ${h.length} actions`);const g=this.registry.getHandler(t);if(!g)return p.error("expansion","No handler available for element",r),!1;p.info("handler",`Using ${g.name} handler`,r);const b=this.getElementText(t),y=d.length>1&&h.length>0;if(await g.replace(t,a,f,c,y?d:void 0,y?h:void 0))return p.info("success",`${g.name} handler succeeded`,r),!0;p.warn("handler",`${g.name} handler failed, trying fallback chain`,r);const E=this.registry.getHandlerChain(t);for(const x of E){if(x===g)continue;if(p.info("fallback",`Trying fallback: ${x.name}`,r),await x.replace(t,a,f,c,y?d:void 0,y?h:void 0))return p.info("success",`Fallback ${x.name} succeeded`,r),!0}return p.error("fail","All handlers failed, rolling back",r),this.rollback(t,b),T.getInstance().markFailed(t),!1}catch(o){const l={...r,error:o instanceof Error?o.message:String(o)};return p.error("fail","Fatal error in replace",l),console.error("TextBlitz: Fatal error:",o),T.getInstance().markFailed(t),!1}}static getElementText(t){return t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement?t.value:t.textContent||""}static rollback(t,e){try{t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement?(t.value=e,t.dispatchEvent(new Event("input",{bubbles:!0}))):t.isContentEditable&&(t.textContent=e,t.dispatchEvent(new Event("input",{bubbles:!0}))),this.log("Rolled back to previous content")}catch(n){console.error("TextBlitz: Rollback failed:",n)}}static isValidInputElement(t){return t instanceof HTMLInputElement&&t.type==="password"||t instanceof HTMLInputElement&&t.type==="hidden"||t instanceof HTMLInputElement&&["number","date","time","color","range","file","datetime-local","month","week"].includes(t.type)?!1:t instanceof HTMLInputElement||t instanceof HTMLTextAreaElement||t.isContentEditable}static listHandlers(){return this.registry.listHandlers()}};C.debugMode=!1,C.registry=new L;let k=C;export{k as TextReplacer};
